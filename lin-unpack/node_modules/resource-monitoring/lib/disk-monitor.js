'use strict';

var fs = require('fs');
var path = require('path');

var async = require('async');

var DiskMonitor = function DiskMonitor(intervalSeconds, logger) {
	this.intervalSeconds = intervalSeconds;
	this.log = logger;

	this.diskStats = {};
	this._prevDiskIO = {};

	this.supportsDiskStats = (process.platform == 'linux' || process.platform == 'darwin');

	if(this.supportsDiskStats) {
		this.disks = require('nodejs-disks');
		this.procfs = require('procfs-stats');

		var fdsPath = path.join('/proc', process.pid.toString(), 'fd');
		this.supportsFDsCount = true;
		try {
			fs.accessSync(fdsPath, fs.R_OK);
		} catch(ex) {
			this.supportsFDsCount = false;
			this.log.perf.warn(ex);
		}
		if(this.supportsFDsCount) {
			this.ps = this.procfs(process.pid);
		}
	}

	if(!this.supportsDiskStats) {
		this.log.perf.info('Disk statistics are only available in Unix-based OSs');
	} else if(!this.supportsFDsCount) {
		this.log.perf.info('No access to path %s; File descriptors count will be invalid', fdsPath);
	}
};

DiskMonitor.prototype._perSecond = function _perSecond(newValue, oldValue) {
	return (newValue - oldValue) / this.intervalSeconds;
};

DiskMonitor.prototype.collect = function(callback) {
	var $this = this;
	if(!this.supportsDiskStats) {
		return callback(null, {});
	} else {
		this.diskStats = {};

		async.parallel({
			io: function (cb) {
				$this.procfs.disk(cb);
			},
			numFD: function (cb) {
				if($this.supportsFDsCount) {
					$this.ps.fds(cb);
				} else {
					cb(null, []);
				}
			},
			usage: function (cb) {
				$this.disks.drives(function (err, drives) {
					if(err) {
						return cb(err, []);
					}
					drives = drives.filter(function (d) {
						return !!d.match(/^\/dev/);
					});
					$this.disks.drivesDetail(drives, cb);
				});
			}
		}, function (err, result) {
			if(err) {
				this.log.perf.error({err: err}, 'Unable to collect disk statistics');
				return callback(err, {});
			}
			if(result.usage && result.io && result.io.length > 0) {
				var diskNames = result.usage.map(function (detail) {
					return detail.drive.match(/\/dev\/(\w+)/)[1];
				});
				var diskStats = result.io[0].filter(function (stat) {
					return diskNames.indexOf(stat.device) >= 0;
				});

				this.diskStats.io = diskStats.map(function (stat) {
					var prevStat = this._prevDiskIO[stat.device] || {
							weightedIoMs: 0,
							ops: 0
						};
					return {
						device: stat.device,
						// % of time spend doing IO
						utilizationPerc: (((parseInt(stat.ms_weighted_io) - prevStat.weightedIoMs) / (this.intervalSeconds * 1000)) * 100).toFixed(3),
						// amount of data being written, kb/s
						//rate: 0,	TODO: we can calculate it easily in # sectors
						// operations per second
						ops: this._perSecond(parseInt(stat.writes_completed) + parseInt(stat.reads_completed), prevStat.ops).toFixed(3)
					}
				}.bind(this));

				diskStats.forEach(function (stat) {
					this._prevDiskIO[stat.device] = {
						ops: parseInt(stat.writes_completed) + parseInt(stat.reads_completed),
						weightedIoMs: parseInt(stat.ms_weighted_io)
					}
				}.bind(this));
			}

			if(result.usage) {
				// collect percentage of usage, available space and drive name of the fullest drive
				var usedPerc = result.usage.map(function (detail) {
					return parseInt(detail.usedPer);
				});

				var maxUsed = Math.max.apply(null, usedPerc);
				var fullestDrive = result.usage[usedPerc.indexOf(maxUsed)];
				this.diskStats.usage = {
					maxUsedPerc: maxUsed,
					fullestAvailable: fullestDrive.available,
					fullestName: fullestDrive.drive
				};
			}

			if(result.numFD) {
				this.diskStats.numFD = result.numFD.length;
			}

			callback(null, this.diskStats);
		}.bind(this));
	}
};

module.exports = DiskMonitor;