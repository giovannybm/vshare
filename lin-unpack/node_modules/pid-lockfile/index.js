'use strict';

var fs = require('fs');
var path = require('path');
var extend = require('lodash').extend;
var async = require('async');
var syncFs = require('./lib/syncFs');

var locks = {};

function createError(msg, code) {
	var err =  msg instanceof Error ? msg : new Error(msg);

	if (code != null) {
		err.code = code;
	}

	return err;
}

function getLockFile(file) {
		return file + '.lock';
}

function canonicalPath(file, options, callback) {
		if (!options.realpath) {
				return callback(null, path.resolve(file));
		}

		// Use realpath to resolve symlinks
		// It also resolves relative paths
		options.fs.realpath(file, callback);
}

function acquireLock(file, options, callback) {
		// Use mkdir to create the lockfile (atomic operation)
		options.fs.open(getLockFile(file), 'wx', function (err, fd) {
				// If successful, we are done
				if (!err) {
						return fs.write(fd, process.pid, callback);
				}

				// If error is not EEXIST then some other error occurred while locking
				if (err.code !== 'EEXIST') {
						return callback(err);
				}

				// Otherwise, check if lock is stale by analyzing the file mtime
				if (options.stale <= 0) {
						return callback(createError('Lock file is already being hold', 'ELOCKED', { file: file }));
				}

				options.fs.stat(getLockFile(file), function (err, stat) {
						if (err) {
								// Retry if the lockfile has been removed (meanwhile)
								// Skip stale check to avoid recursiveness
								if (err.code === 'ENOENT') {
										return acquireLock(file, extend({}, options, { stale: 0 }), callback);
								}

								return callback(err);
						}

						if (stat.mtime.getTime() >= Date.now() - options.stale) {
								return callback(createError('Lock file is already being hold', 'ELOCKED', { file: file }));
						}

						// If it's stale, remove it and try again!
						// Skip stale check to avoid recursiveness
						removeLock(file, options, function (err) {
								if (err) {
										return callback(err);
								}

								acquireLock(file, extend({}, options, { stale: 0 }), callback);
						});
				});
		});
}

function removeLock(file, options, callback) {
		// Remove lockfile, ignoring ENOENT errors
		options.fs.unlink(getLockFile(file), function (err) {
				if (err && err.code !== 'ENOENT') {
						return callback(err);
				}

				callback();
		});
}

function isLockStale(lock) {
	// Verify if we are within the stale threshold
	if (lock.lastUpdate <= Date.now() - options.stale) {
		return true;
	}

	// If not, we're the second process trying to acquire the same lock
	return false;
}

function updateLock(file, options) {
		var lock = locks[file];

		if (!lock || lock.updateTimeout) {
				return;
		}

		lock.updateDelay = lock.updateDelay || options.update;
		lock.updateTimeout = setTimeout(function () {
				var mtime = Date.now() / 1000;

				lock.updateTimeout = null;

				async.waterfall([
					function readLockFile(cb) {
						// read pid
						options.fs.readFile(getLockFile(file), 'utf8', cb);
					},
					function checkPid(pid, cb) {
						if(pid != process.pid
							&& !lock.released //Ignore staleness check if the lock was released
							&& !isLockStale(lock)) {
							return cb(createError(new Error('Trying to acquire lock file of different process'), 'ECOMPROMISED'));
						}
						return cb(null);
					},
					function updateMTime(cb) {
						options.fs.utimes(getLockFile(file), mtime, mtime, cb);
					}
				], function(err) {
					if (err) {
						// If it failed to update the lockfile, keep trying unless
						// the lockfile was deleted or otherwise compromised
						if (err.code === 'ENOENT' || err.code === 'ECOMPROMISED') {
							return compromisedLock(file, lock, createError(err, 'ECOMPROMISED'));
						}

						lock.updateError = err;
						lock.updateDelay = 500;
						return updateLock(file, options);
					}

					// All ok, keep updating..
					lock.lastUpdate = Date.now();
					lock.updateError = null;
					lock.updateDelay = null;
					updateLock(file, options);
				});
		}, lock.updateDelay);

		// Unref the timer so that the nodejs process can exit freely
		// This is safe because all acquired locks will be automatically released
		// on process exit
		lock.updateTimeout.unref();
}

function compromisedLock(file, lock, err) {
		lock.released = true;                                    // Signal the lock has been released
		/* istanbul ignore next */
		lock.updateTimeout && clearTimeout(lock.updateTimeout);  // Cancel lock mtime update

		if (locks[file] === lock) {
				delete locks[file];
		}

		lock.compromised(err);
}

// -----------------------------------------

function lock(file, options, compromised, callback) {
		if (typeof options === 'function') {
				callback = compromised;
				compromised = options;
				options = null;
		}

		if (!callback) {
				callback = compromised;
				compromised = null;
		}

		options = extend({
				stale: 10000,
				update: null,
				realpath: true,
				fs: fs
		}, options);

		options.stale = Math.max(options.stale || 0, 1000);
		options.update = options.update == null ? options.stale / 2 : options.update || 0;
		options.update = Math.max(Math.min(options.update, options.stale / 2), 500);
		compromised = compromised || function (err) { throw err; };

		// Resolve to a canonical file path
		canonicalPath(file, options, function (err, file) {
				if (err) {
						return callback(err);
				}

				// Attempt to acquire the lock
				acquireLock(file, options, function (err) {
						var lock;

						if (err) {
								return callback(err);
						}

						// We now own the lock
						locks[file] = lock = {
								options: options,
								compromised: compromised,
								lastUpdate: Date.now()
						};

						// We must keep the lock fresh to avoid staleness
						updateLock(file, options);

						callback(null, function (releasedCallback) {
								if (lock.released) {
										return releasedCallback && releasedCallback(createError('Lock is already released', 'ERELEASED'));
								}

								// Not necessary to use realpath twice when unlocking
								unlock(file, extend({}, options, { realpath: false }), releasedCallback);
						});
				});
		});
}

function unlock(file, options, callback) {
		if (typeof options === 'function') {
				callback = options;
				options = null;
		}

		options = extend({
				fs: fs,
				realpath: true
		}, options);

		callback = callback || function () {};

		// Resolve to a canonical file path
		canonicalPath(file, options, function (err, file) {
				var lock;

				if (err) {
						return callback(err);
				}

				// Skip if the lock is not acquired
				lock = locks[file];
				if (!lock) {
						return callback(createError('Lock is not acquired/owned by you', 'ENOTACQUIRED'));
				}

				lock.updateTimeout && clearTimeout(lock.updateTimeout);  // Cancel lock mtime update
				lock.released = true;                                    // Signal the lock has been released
				delete locks[file];                                      // Delete from locks

				removeLock(file, options, callback);
		});
}

function lockSync(file, options, compromised) {
		var err,
				release;

		if (typeof options === 'function') {
				compromised = options;
				options = null;
		}

		options = options || {};
		options.fs = syncFs(options.fs || fs);

		lock(file, options, compromised, function (_err, _release) {
				err = _err;
				release = _release;
		});

		if (err) {
				throw err;
		}

		return release;
}

function unlockSync(file, options) {
		var err;

		options = options || {};
		options.fs = syncFs(options.fs || fs);

		unlock(file, options, function (_err) {
				err = _err;
		});

		if (err) {
				throw err;
		}
}


// Remove acquired locks on exit
process.on('exit', function () {
		Object.keys(locks).forEach(function (file) {
				try { locks[file].options.fs.rmdirSync(getLockFile(file)); } catch (e) {}
		});
});

module.exports = lock;
module.exports.lock = lock;
module.exports.unlock = unlock;
module.exports.lockSync = lockSync;
module.exports.unlockSync = unlockSync;
