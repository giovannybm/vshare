'use strict';

var fs = require('fs');
var path = require('path');
var forge = require('node-forge');
var mkdirp = require('mkdirp');

/**
 *
 * @param {string} privateKey
 * @param {string?} passphrase
 * @returns {Object} the pem (to store)
 */
function privateKeyToPem(privateKey, passphrase) {
	return (passphrase != null) ?
		//with passphrase
		forge.pki.encryptRsaPrivateKey(
			privateKey,
			passphrase,
			{algorithm: 'aes256', legacy: true}
		) :
		//without passphrase
		forge.pki.privateKeyToPem(privateKey);
}

function generateKeyPair(options, callback) {
	callback = callback || function () {};

	forge.pki.rsa.generateKeyPair(2048, function (err, keys) {
		if (err) {
			callback(err, null);
		} else {
			const pem = privateKeyToPem(keys.privateKey, options.passphrase);
			if (options.filename) {
				mkdirp.sync(path.dirname(options.filename));
				fs.writeFile(options.filename, pem, function (err) {
					callback(err, err ? null : keys);
				});
			} else {
				callback(null, keys);
			}
		}
	});
}

function generateSigningRequest(options, callback) {
	callback = callback || function () {};
	try {
		// create a certification request (CSR)
		var csr = forge.pki.createCertificationRequest();
		csr.publicKey = options.keys.publicKey;
		csr.setSubject(options.subject);
		csr.sign(options.keys.privateKey);

		var pem = forge.pki.certificationRequestToPem(csr);
		if (options.filename) {
			mkdirp.sync(path.dirname(options.filename));
			fs.writeFile(options.filename, pem, function (err) {
				callback(err, err ? null : pem);
			});
		} else {
			callback(null, csr);
		}
	} catch (fileError) {
		callback(fileError);
	}
}

function verifyCertificateRequest(csrContent, callback) {
	callback = callback || function () {};
	var csr = forge.pki.certificationRequestFromPem(csrContent);
	if (!csr.verify()) {
		return callback(new Error('Invalid CSR.'));
	}
	callback(null, true);
}

module.exports.generateCsr = function (options, callback) {
	var privateKeyOptions = {
		passphrase: options.passphrase,
		filename: options.keyFile
	};
	var subject = [{
		name: 'commonName',
		value: options.name
	}];
	var certificationRequestOptions = {
		subject: subject,
		filename: options.csrFile
	};
	generateKeyPair(privateKeyOptions, function (err, keys) {
		if (!err) {
			certificationRequestOptions.keys = keys;
			generateSigningRequest(certificationRequestOptions, callback);
		} else {
			callback(err);
		}
	});
};

module.exports.verifyCsr = function(csr, callback) {
	verifyCertificateRequest(csr, callback);
};

module.exports.privateKeyToPem = privateKeyToPem;

module.exports.rootCrtPath = path.resolve(__dirname, './crts/rootca.crt');
module.exports.intermediateCrtPath = path.resolve(__dirname, './crts/intca.crt');
