'use strict';

var os = require('os');
var path = require('path');
var fs = require('fs');
var async = require('async');

var lockFile = require('pid-lockfile');

var InstanceLock = function InstanceLock(name, logger) {
	this.filename = path.join(os.tmpdir(), name);
	this.logger = logger;
	this.options = {
		realpath: false,
		stale: 1000,
		update: 500
	};
};

InstanceLock.prototype.compromised = function(err) {
	this.logger.system.warn({err: err}, 'Possibly compromised lockfile %s. Process will now exit', this.filename);
	this.onCompromised();
};

InstanceLock.prototype.acquire = function acquire(onCompromised) {
	this.onCompromised = onCompromised;

	// Temporary backwards compatibility workaround:
	// removing obsolete lock directory from old versions
	try {
		var lockDirPath = this.filename + '.lock';
		var lockDir = fs.statSync(lockDirPath);
		if(lockDir && lockDir.isDirectory()) {
			fs.rmdirSync(lockDirPath);
		}
	} catch(err) {
	}

	try {
		lockFile.lockSync(this.filename, this.options, this.compromised.bind(this));
		this.logger.system.info('Acquired lockfile %s', this.filename + '.lock');
		return true;
	} catch(err) {
		this.logger.system.warn({err: err}, 'Unable to acquire lockfile %s. Process is single instance', this.filename);
		return false;
	}
};

InstanceLock.prototype.release = function release() {
	try {
		lockFile.unlockSync(this.filename, this.options);
		this.logger.system.info('Released lockfile %s', this.filename + '.lock');
	} catch(err) {
		this.logger.system.error({err: err}, 'Unable to release lockfile %s. Please try to delete it manually', this.filename);
	}
};

var LifecycleManager = function LifecycleManager(name, logger) {
	this.startHandlers = [];
	this.exitHandlers = [];

	this.name = name;
	this.logger = logger;
	if(!this.logger.system) {
		console.warn('Logger is not initialized in LifecycleManager; will log on console');
		this.logger.system = {
			info: console.info.bind(console),
			warn: console.warn.bind(console),
			error: console.error.bind(console),
			fatal: function(err, msg) {
				console.error(msg);
				console.error(err.stack);
			}
		};
	}

	process.once('uncaughtException', function (err) {
		console.error(err);
		process.on('uncaughtException', function (err) {
			console.error(err);
		});
		this.logger.system.fatal(err, 'Unhandled exception.');
		this.shutdown(1);
	}.bind(this));

	process.once('beforeExit', function () {
		this.logger.system.info('Event loop complete.');
		this.shutdown(0);
	}.bind(this));

	var signals = [ 'SIGUSR1', 'SIGTERM', 'SIGINT', 'SIGHUP', 'SIGBREAK' ];
	signals.forEach(function (signal) {
		process.once(signal, function () {
			this.logger.system.info('%s signal received.', signal);
			this.shutdown(0);
		}.bind(this));
	}.bind(this));

};

LifecycleManager.prototype.ensureSingleInstance = function ensureSingleInstance() {
	this.lock = new InstanceLock(this.name, this.logger);
	if (!this.lock.acquire(this.shutdown.bind(this, 0, false))) {
		this.shutdown(0, false);
		return false;
	}
	return true;
};

LifecycleManager.prototype.shutdown = function shutdown(code, unlock) {
	if (unlock === undefined) {
		unlock = true;
	}

	this.logger.system.info('Shutting down.');

	if(unlock && this.lock) {
		this.lock.release();
	}

	async.parallel(this.exitHandlers, function(err) {
		if(err) {
			console.error('Error while finishing process:', err.message);
			console.error(err.stack);
		}
		process.exit(code);
	})
};

LifecycleManager.prototype.onStart = function(handler) {
	this.startHandlers.push(handler);
};

LifecycleManager.prototype.onExit = function(handler) {
	this.exitHandlers.push(handler);
};

var instance;
module.exports = function(name, logger) {
	if(!instance) {
		instance = new LifecycleManager(name, logger);
	}
	return instance;
};
