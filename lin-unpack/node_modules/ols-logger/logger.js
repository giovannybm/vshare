'use strict';

var fs = require('fs');
var zlib = require('zlib');

var async = require('async');
var bunyan = require('bunyan');
var _ = require('lodash');
var path = require('path');
var uuid = require('node-uuid');
var mkdirp = require('mkdirp');
var PrettyStream = require('bunyan-prettystream');

// instances

var LoggerInstance = function (config) {
	var logger = this;

	logger.name = config.name;
	logger.errorStream = new bunyan.RingBuffer({ limit: 100 });

	logger.system = new CreateComponentLog(config, 'system', logger.errorStream);
	logger.perf = new CreateComponentLog(config, 'perf', logger.errorStream);
	logger.user = new CreateComponentLog(config, 'user', logger.errorStream);

	[logger.system, logger.user, logger.perf].forEach(
		logger.setupCompression.bind(logger)
	);

	logger.finalize = function finalize(callback) {
		var finalizers = [];
		[logger.system, logger.user, logger.perf].forEach(function (component) {
			component.streams.forEach(function (stream) {
				// stream == bunyan stream
				// stream.stream == rotating file stream
				// stream.stream.stream == writable file stream
				if (stream.stream && stream.stream.stream) {
					finalizers.push(function (callback) {
						setImmediate(stream.stream.stream.end.bind(stream.stream.stream));
						stream.stream.stream.once('finish', callback);
						stream.stream.stream.once('error', callback);
					});
				}
			});
		});
		async.parallel(finalizers, callback);
	}
};

LoggerInstance.prototype.setupCompression = function setupCompression(component) {
	var logger = this;

	component.streams.forEach(function (stream) {
		if (stream.type == 'rotating-file' && stream.stream) {
			// sneak in some compression
			stream.stream.on('drain', function () {
				var gzip = zlib.createGzip({ level: 9 });
				var $in = fs.createReadStream(this.path + '.0');
				var out = fs.createWriteStream(this.path + '.0.tmp');
				$in.pipe(gzip).pipe(out);
				out.once('finish', function () {
					fs.rename(out.path, $in.path, function (err) {
						if (err) {
							logger.system.error(err, 'Failed to compress logs.');
						}
					});
				});
				out.once('error', function (err) {
					logger.system.error(err, 'Failed to compress logs.');
				});
			});
		}
	});
};

var CreateComponentLog = function(config, component, errorStream) {
	config.serializers = config.serializers || {};
	config.serializers.req = bunyan.stdSerializers.req;
	config.serializers.res = bunyan.stdSerializers.res;
	config.serializers.err = bunyan.stdSerializers.err;
	config.serializers.https = function (options) {
		return _.omit(options, [
			'ca', 'cert', 'key', 'passphrase', 'ciphers', 'secureCipher', 'jar'
		]);
	};

	if(!fs.existsSync(config.directory)) {
		mkdirp.sync(config.directory);
	}
	var bunyanConfig = {
		name: config.name,
		streams: [{
			level: config[component].file,
			path: path.resolve(config.directory, component + '.log'),
			type: config.clusterMode ? 'file' : 'rotating-file',
			period: '1d',
			count: 7
		},
		{
			level: 'warn',
			type: 'raw',
			stream: errorStream
		}],
		serializers: config.serializers
	};

	if(config[component].console) {
		var stdout;
		if (config.prettyPrint && Boolean(process.stdout.isTTY)) {
			stdout = new PrettyStream();
			stdout.pipe(process.stdout);
		} else {
			stdout = process.stdout;
		}

		bunyanConfig.streams.push({
			level: config[component].console,
			stream: stdout
		})

	}

	if (config[component].db) {
		var MongoStream = require('bunyan-mongo-stream');
		var mongoStream = new MongoStream(config.dbConnectionString, {collection_name: component});

		bunyanConfig.streams.push({
			level: config[component].db,
			type: 'raw',
			stream: mongoStream
		});
	}

	if (config[component].stackdriver) {
		if (!module_exist('bunyan-stackdriver')) {
			console.error('ERROR: Missing Bunyan Stackdriver module. Skipping Stackdriver streaming.');
		} else {
			var BunyanStackDriver = require('bunyan-stackdriver');

			var stackDriverStream = new BunyanStackDriver({
				keyFilename: config.keyfile,
				projectId: config.projectId,
				log_id: 'default'
			});

			bunyanConfig.streams.push({
				level: config[component].stackdriver,
				type: 'raw',
				stream: stackDriverStream
			});
		}
	}

	return bunyan.createLogger(bunyanConfig);
};

LoggerInstance.prototype.endpoint = function endpoint(req, res, next) {
	var logger = this;

	if (req.cookies.activationToken) {
		logger.user.fields.token = req.cookies.activationToken;
	}
	var reqId = uuid();
	logger.user.trace({ req: req, reqId: reqId }, 'Request begin.');
	res.once('finish', function finishHandler() {
		logger.user.trace({ res: res , reqId: reqId }, 'Request end.');
	});
	res.once('error', function errorHandler(err) {
		logger.user.error({ res: res, reqId: reqId, err: err }, 'Request failed.');
	});
	return next();
};

LoggerInstance.prototype.expressErrorHandler = function expressErrorHandler(err, req, res, next) {
	var logger = this;

	logger.user.error(err, 'HTTP request failed.');
	logger.user.error({req: req}, 'Request details.');
	res.status(500).send();
};

// container

var LoggerContainer = {};

//TODO: remove lifetimeManager param
LoggerContainer.initialize = function initialize(config, lifetimeManager) {
	var instance = new LoggerInstance(config, lifetimeManager);
	this[config.name] = instance;
	return instance;
};

function module_exist(name) {
	try {
		require(name);
	} catch (err) {
		if (err.code === 'MODULE_NOT_FOUND') {
			return false;
		}
	}
	return true;
}

module.exports = LoggerContainer;
